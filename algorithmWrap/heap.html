<!DOCTYLE html>

    <html>

    <head>
    <meta charset="utf-8">
    <meta name="author" content="KIBOK">
    <meta name="description" content="HTML, CSS">
    <meta name="keywords" content="기복, 포트폴리오, 연습, HTML, CSS">

    <link rel="shortcut icon" href="../images/pavicon.png">
    <link rel="stylesheet" href="../css/algorithmCssWrap/heap.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script>
    <title>KIBOK WEB PORTFOLIO</title>
</head>

<body>
    <header>
        <h1><span style="font-weight: 300">HEAP</span> SORT</h1>
        <a href="../algorithm.html" class="back">back</a>
    </header>

    <p class="description">
        - <span class="highlight">Heap</span> 이란?<br><br>
        &nbsp;&nbsp;&nbsp;<span class="highlight">완전 이진 트리</span>의 일종으로 <span class="highlight">우선순위 큐</span>를 위하여 만들어진 자료구조이다<br><br>
        &nbsp;&nbsp;&nbsp;여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다<br><br>
        &nbsp;&nbsp;&nbsp;간단히 말하면 <span class="highlight">부모 노드의 키 값</span>이 <span class="highlight">자식 노드의 키 값</span>보다 <span class="highlight">항상 큰 (작은) 이진 트리</span>를 말한다
    </p>
    <p class="responsiveDescription">
        - <span class="highlight">Heap</span> 이란?<br><br>
        &nbsp;&nbsp;&nbsp;<span class="highlight">완전 이진 트리</span>의 일종으로 <span class="highlight">우선순위 큐</span>를 위하여 만들어진 자료구조이다<br><br>
        &nbsp;&nbsp;&nbsp;여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록<br><br> &nbsp;&nbsp;&nbsp;만들어진 자료구조이다 간단히 말하면 <span class="highlight">부모 노드의 키 값</span>이 <span class="highlight">자식 노드의 키 값</span>보다<br><br><span class="highlight">&nbsp;&nbsp;&nbsp;항상 큰 (작은) 이진 트리</span>를 말한다
    </p>

    <img class="algorithm" src="../images/algorithm/types-of-heap.png" alt="heap sort">

    <p class="description2">
        - <span class="highlight">Heap 정렬</span>이란?<br><br>
        &nbsp;&nbsp;&nbsp;아주 간단히 생각하자면 위의 <span class="highlight">최대힙, 최소힙의 루트 값</span>을 계속 뽑아오면 정렬이 된다 하지만 <span class="highlight">추가 공간이 필요</span>하다<br><br>
        &nbsp;&nbsp;&nbsp;이 문제를 개선한 <span class="highlight">제자리 힙 정렬</span>이 있는데 아래 코드를 보면 이해가 갈 것이다<br><br>
        &nbsp;&nbsp;&nbsp;간단히 설명하자면 힙의 루트 값을 <span class="highlight">힙의 가장 마지막 index</span>로 보낸 후<br><br>
        &nbsp;&nbsp;&nbsp;<span class="highlight">마지막 index를 제외 한 힙</span>을 가지고 계속 반복하는 것이다
    </p>

    <p class="reponsiveDescription2">
        - <span class="highlight">Heap 정렬</span>이란?<br><br>
        &nbsp;&nbsp;&nbsp;아주 간단히 생각하자면 위의 <span class="highlight">최대힙, 최소힙의 루트 값</span>을 계속 뽑아오면<br><br>
        &nbsp;&nbsp;&nbsp;정렬이 된다 하지만 <span class="highlight">추가 공간이 필요</span>하다<br><br>
        &nbsp;&nbsp;&nbsp;이 문제를 개선한 <span class="highlight">제자리 힙 정렬</span>이 있는데 아래 코드를 보면 이해가 갈 것이다<br><br>
        &nbsp;&nbsp;&nbsp;간단히 설명하자면 힙의 루트 값을 <span class="highlight">힙의 가장 마지막 index</span>로 보낸 후<br><br>
        &nbsp;&nbsp;&nbsp;<span class="highlight">마지막 index를 제외 한 힙</span>을 가지고 계속 반복하는 것이다
    </p>

    <a class="viewCode" href="https://github.com/Nam-Ki-Bok/Sort" target="_blank" onmouseover="this.style.color='#5CAAEF'" onmouseout="this.style.color='white'">View Code<span style="font-size: 20px">(github)</span></a>

    <pre><code class="c">
int heap[100];
int heapSize = 0;
int tmpHeapSize;

void swap(int *num1, int *num2) {
    int tmp = *num1;
    *num1 = *num2;
    *num2 = tmp;
}

void downHeap (int index) {
    int parent, leftC, rightC;
    leftC = index * 2;
    rightC = leftC + 1;
    if (leftC > heapSize) {
        return;
    }
    parent = leftC;
    if (rightC &lt;= heapSize) {
        if (heap[rightC] >= heap[parent]) {
            parent = rightC;
        }
    }
    if (heap[index] > heap[parent]) {
        return;
    }
    swap(&amp;heap[index], &amp;heap[parent]);
    downHeap(parent);
}

void buildHeap () {
    for (int i = heapSize / 2;i >= 1;i--) {
        downHeap(i);
    }
}

void inplaceHeapSort () {
    for (int i = heapSize;i >= 2;i--) {
        swap(&amp;heap[1], &amp;heap[i]);
        heapSize -= 1;
        downHeap(1);
    }
}

void printHeap () {
    for (int i = 1;i &lt;= tmpHeapSize;i++) {
        printf(" %d", heap[i]);
    }
    puts("");
}
</code></pre>

</body></html>
