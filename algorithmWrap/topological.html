<!DOCTYLE html>

    <html>

    <head>
    <meta charset="utf-8">
    <meta name="author" content="KIBOK">
    <meta name="description" content="HTML, CSS">
    <meta name="keywords" content="기복, 포트폴리오, 연습, HTML, CSS">

    <link rel="shortcut icon" href="../images/pavicon.png">
    <link rel="stylesheet" href="../css/algorithmCssWrap/topological.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script>
    <title>KIBOK WEB PORTFOLIO</title>
</head>

<body>
    <header>
        <h1><span style="font-weight: 300">TOPOLOGICAL</span> SORT</h1>
        <a href="../algorithm.html" class="back">back</a>
    </header>

    <p class="description">
        - 어떤 일을 하는 순서를 찾는 알고리즘이다<br><br>
        &nbsp;&nbsp;&nbsp;즉, 방향 그래프에 존재하는 각 정점들의 <span class="highlight">선행 순서를 위배하지 않으면서 모든 정점을 나열</span>하는 것
    </p>
    <p class="responsiveDescription">
        - 어떤 일을 하는 순서를 찾는 알고리즘이다<br><br>
        &nbsp;&nbsp;&nbsp;즉, 방향 그래프에 존재하는 각 정점들의<br><br>
        &nbsp;&nbsp;&nbsp;<span class="highlight">선행 순서를 위배하지 않으면서 모든 정점을 나열</span>하는 것
    </p>

    <img class="algorithm" src="../images/algorithm/topological-sort.png" alt="topological sort">

    <p class="description2">
        - 위상정렬을 이해하기 위해선 먼저 자료구조인 <a class="graphLink" href="#">그래프</a>를 알아야 한다<br><br><br>
        - <span class="highlight">방향그래프가 싸이클이 없다면 위상정렬</span>을 가지고, 그 역도 참인 특징이 있다<br><br><br>
        - 위상정렬은 <span class="highlight">정점의 진입차수를 이용하는 방법</span>과 <span class="highlight">DFS를 이용하는 방법</span>이 있다<br><br>
        &nbsp;&nbsp;&nbsp;정점의 진입차수를 이용하는 방법은 DAG가 아닌 경우 일부 정점의<br><br>&nbsp;&nbsp;&nbsp;순서를 정하지 않은채로 멈춘다<br><br>
        &nbsp;&nbsp;&nbsp;DFS를 이용하는 경우 싸이클이 있더라도 허위의 순서를 계산한다<br><br>
        &nbsp;&nbsp;&nbsp;그 중 DFS(깊이우선탐색)를 이용하는 방법에 대해 알아보겠다<br><br><br>
        - 왼쪽의 그림이 DFS를 이용한 위상정렬을 나타낸 그림이다<br><br>
        &nbsp;&nbsp;&nbsp;아주 간단히 생각하면 DFS 과정 중 정점에 순위를 부여해주기만 하면 된다<br><br><br>
        - 여러가지 그래프를 표현하는 방법이 있지만<br><br>
        &nbsp;&nbsp;&nbsp;간단한 방법인 정점 배열과 부착리스트를 사용해 구현했다<br><br>
        &nbsp;&nbsp;&nbsp;아래 코드는 위상순서와 방문한 간선의 총 무게를 출력하는 코드이다<br><br>
        &nbsp;&nbsp;&nbsp;정점, 간선 갯수를 입력하고 각 간선의 시작점, 끝점, 무게를 입력한다
    </p>

    <p class="reponsiveDescription2">
        - 위상정렬을 이해하기 위해선 먼저 자료구조인<br><br>
        &nbsp;&nbsp;&nbsp;<a class="graphLink" href="#">그래프</a>를 알아야 한다<br><br><br>
        - <span class="highlight">방향그래프가 싸이클이 없다면 위상정렬</span>을 가지고<br><br>
        &nbsp;&nbsp;&nbsp;그 역도 참인 특징이 있다<br><br><br>
        - 위상정렬은 <span class="highlight">정점의 진입차수를 이용하는 방법</span>과<br><br>
        &nbsp;&nbsp;&nbsp;<span class="highlight">DFS를 이용하는 방법</span>이 있다<br><br>
        &nbsp;&nbsp;&nbsp;정점의 진입차수를 이용하는 방법은<br><br>
        &nbsp;&nbsp;&nbsp;DAG가 아닌 경우 일부 정점의 순서를 정하지 않은채로 멈춘다<br><br>
        &nbsp;&nbsp;&nbsp;DFS를 이용하는 경우 싸이클이 있더라도<br><br>
        &nbsp;&nbsp;&nbsp;허위의 순서를 계산한다<br><br>
        &nbsp;&nbsp;&nbsp;그 중 DFS(깊이우선탐색)를 이용하는 방법에 대해 알아보겠다<br><br><br>
        - 왼쪽의 그림이 DFS를 이용한 위상정렬을 나타낸 그림이다<br><br>
        &nbsp;&nbsp;&nbsp;아주 간단히 생각하면 DFS 과정 중<br><br>
        &nbsp;&nbsp;&nbsp;정점에 순위를 부여해주기만 하면 된다<br><br><br>
        - 여러가지 그래프를 표현하는 방법이 있지만<br><br>
        &nbsp;&nbsp;&nbsp;간단한 방법인 정점 배열과 부착리스트를 사용해 구현했다<br><br>
        &nbsp;&nbsp;&nbsp;아래 코드는 위상순서와 방문한 간선의<br><br>
        &nbsp;&nbsp;&nbsp;총 무게를 출력하는 코드이다<br><br>
        &nbsp;&nbsp;&nbsp;정점, 간선 갯수를 입력하고<br><br>
        &nbsp;&nbsp;&nbsp;각 간선의 시작점, 끝점, 무게를 입력한다
    </p>

    <a class="viewCode" href="https://github.com/Nam-Ki-Bok/Sort" target="_blank" onmouseover="this.style.color='#5CAAEF'" onmouseout="this.style.color='white'">View Code<span style="font-size: 20px">(github)</span></a>

    <pre><code class="c">
typedef struct Vertex {
	int vertexNum;
	int isVisited;
	int topologicalRank;
	struct Edge *header;
}Vertex;

typedef struct Edge {
	int oppositeNum;
	int weight;
	struct Edge *next;
}Edge;

Edge *getEdge() {
	Edge *newEdge = (Edge *)malloc(sizeof(Edge));
	newEdge->next = NULL;
	newEdge->oppositeNum = 0;
	newEdge->weight = 0;
	return newEdge;
}

void buildEdge(Vertex *vertexArray, int startVertexNum, int endVertex, int weight) {
	Edge *cur = vertexArray[startVertexNum - 1].header;
	Edge *newEdge = getEdge();
	newEdge->oppositeNum = endVertex;
	newEdge->weight = weight;

	if (cur->next == NULL) {
		cur->next = newEdge;
	}
	else {
		while (cur->next->oppositeNum &lt; endVertex) {
			cur = cur->next;
			if (cur->next == NULL)
				break;
		}
		newEdge->next = cur->next;
		cur->next = newEdge;
	}
}

void buildGraph(Vertex *vertexArray, int vertexNum, int edgeNum) {
	for (int i = 0;i &lt; vertexNum;i++) {
		vertexArray[i].header = getEdge();
		vertexArray[i].isVisited = 0;
		vertexArray[i].vertexNum = i + 1;
	}

	int startVertex, endVertex, weight;
	for (int i = 0;i &lt; edgeNum;i++) {
		scanf("%d%d%d",  &amp;startVertex, &amp;endVertex, &amp;weight);
		buildEdge(vertexArray, startVertex, endVertex, weight);
	}
}

void rDFS_topologicalSort(Vertex *vertexArray, Vertex *checkVertex, int *sumWeight, int *topologicalRank) {
	Edge *cur = checkVertex->header;
	checkVertex->isVisited = 1;
	
	while (cur) {
		if (vertexArray[cur->oppositeNum - 1].isVisited == 0) {
			*sumWeight += cur->weight;
			rDFS_topologicalSort(vertexArray, &amp;vertexArray[cur->oppositeNum - 1], sumWeight, topologicalRank);
		}
		cur = cur->next;
	}
	checkVertex->topologicalRank = *topologicalRank;
	*topologicalRank -= 1;
}

void DFS_topologicalSort(Vertex *vertexArray, int vertexNum, int *sumWeight, int *topologicalRank) {
	for (int i = 0;i &lt; vertexNum;i++) {
		if (vertexArray[i].isVisited == 0) {
			rDFS_topologicalSort(vertexArray, &amp;vertexArray[i], sumWeight, topologicalRank);
		}
	}
}

int main() {
	int vertexNum, edgeNum, sumWeight = 0;
	scanf("%d%d", &amp;vertexNum, &amp;edgeNum);
	int topologicalRank = vertexNum;
	Vertex *vertexArray = (Vertex *)malloc(sizeof(Vertex)*vertexNum);
	
	buildGraph(vertexArray, vertexNum, edgeNum);
	DFS_topologicalSort(vertexArray, vertexNum, &amp;sumWeight, &amp;topologicalRank);

	int rank = 1;
	for (int i = 0;i &lt; vertexNum;i++) {
		for (int j = 0;j &lt; vertexNum;j++) {
			if (vertexArray[j].topologicalRank == rank) {
				printf("%d ", vertexArray[j].vertexNum);
				rank++;
			}
		}
	}

	printf("\n%d\n", sumWeight);
	return 0;
}
</code></pre>

</body></html>
